; VDC Screen Editor
; Screen editor for the C128 80 column mode
; Written in 2021 by Xander Mol

; https://github.com/xahmol/VDCScreenEdit
; https://www.idreamtin8bits.com/

; Assemnbly for output of VDCSE2PRG generator

	; System addresses
	SCROLY					= $D011		; Vertical smooth scrolling and control register
	CLKRATE					= $D030		; Processor clock rate: 0 = 1 MHZ, 1 = 2Mhz
    VDC_ADDRESS_REGISTER    = $D600     ; VDC Adress register address
    VDC_DATA_REGISTER       = $D601     ; VDC Data register address
	SWAPPER					= $FF5F		; SWAPPER kernal call: switch between 40 and 80 columns
	DLCHR					= $FF62		; DLCHR kernal call for resetting VDC charsets
	CINT					= $FF81		; CINT kernal call for initialize screen editor
	BSOUT					= $FFD2		; BSOUT kernal call for printing a character
    GETIN                   = $FFE4     ; GETIN kernal call for reading keyboard buffer
	MODE					= $D7		; Active screen flag, check bit 7: if set->80 column

    ; VDC registers
    VDC_UPDATEADRESSHIGH    = $12       ; VDC Register Update Address High Byte
    VDC_UPDATEADRESSLOW     = $13       ; VDC Refister Update Address Low Byte
    VDC_DATA                = $1F       ; VDC data register
    VDC_FGBGCOLOR           = $1A       ; VDC Foreground/Background color

    ; Zero page addresses
    ZP1                     = $FB       ; First zero page address used
    ZP2                     = $FC       ; First zero page address used

    ; Segment to store code in
    .segment    "PRGGEN"

    ; Load address
    .word $1C01

    ; BASIC header:
	; 10 SYS7302
	.byte $0b,$1c,$0a,$00,$9e
	.byte "7302"
	.byte $00,$30,$1c
	
	; 20 REM generated by vdc screen editor
	.byte $14,$00,$8f,$20
	.byte "generated by vdc screen editor"
	.byte $00,$55,$1c
	
	;30 REM version
	.byte $1e,$00,$8f,$20
	.byte "version 0123456789012345678901"
	.byte $00,$79,$1c
	
	;40 REM written in 2022 by xander mol
	.byte $28,$00,$8f,$20
	.byte "written in 2022 by xander mol"
	.byte $00,$00,$00

    ; Variables
bgcolor:
    .res 1                              ; $1C7B: background color
charsetaddress_std:
    .res 2                              ; $1C7C (low byte)/$1C7D (high byte) standard charset address
charsetaddress_alt:
    .res 2                              ; $1C7E (low byte)/$1C7F (high byte) alternate charset address
pages:
    .res 1								; $1C80: number of pages
length:
    .res 1								; $1C81: length
_VDC_addrl:
	.res	1							; $1C82: source address low byte
_VDC_addrh:
	.res	1							; $1C83: source address high bye
_VDC_destl:
	.res	1							; $1C84: VDC destination address low byte
_VDC_desth:
	.res	1							; $1C85: VDC destination address high bye

	; Check if active screen is 40 or 80 column
	lda MODE							; Check display mode
	bmi vdcmode							; Branch if 80 column

    ; Show message in 40 column mode
	lda #<switchvdcmessage					; Low byte of text address
	sta ZP1								; Store low byte in zero page
	lda #>switchvdcmessage					; Low byte of text address
	sta ZP2								; Store low byte in zero page
	jsr textout							; Print message
	jsr SWAPPER							; Switch to 80 column mode

vdcmode:
	; Set VDC background color
    ldx #VDC_FGBGCOLOR
    lda bgcolor
    jsr VDC_Write

    ; Redefine standard charset if address is set
    lda charsetaddress_std+1            ; Load high byte of standard charset address variable
    cmp #$00                            ; Compare to zero to see if address is set
    beq alternatecharcheck              ; Branch if it equals to zero=no redefine needed
    lda #$FF                            ; Load 255 for 256 characters
    sta length                          ; Store as length
    lda charsetaddress_std              ; Load low byte of standard charset address
    sta _VDC_addrl                      ; Store low byte source address
    lda charsetaddress_std+1            ; Load high byte of standard charset address
    sta _VDC_addrh                      ; Store low byte source address
    lda #$00                            ; Load $00 for low byte of $2000
    sta _VDC_destl                      ; Store low byte destination address
    lda #$20                            ; Load $20 for high bye of $2000
    sta _VDC_desth                      ; Store low byte destination address
    jsr _VDC_RedefineCharset_core       ; Jump to redefine charset routine

alternatecharcheck:
    ; Redefine alternate charset if address is set
    lda charsetaddress_alt+1            ; Load high byte of standard charset address variable
    cmp #$00                            ; Compare to zero to see if address is set
    beq _VDC_CopyMemToVDC_core          ; Branch if it equals to zero=no redefine needed
    lda #$FF                            ; Load 255 for 256 characters
    sta length                          ; Store as length
    lda charsetaddress_alt              ; Load low byte of standard charset address
    sta _VDC_addrl                      ; Store low byte source address
    lda charsetaddress_alt+1            ; Load high byte of standard charset address
    sta _VDC_addrh                      ; Store low byte source address
    lda #$00                            ; Load $00 for low byte of $3000
    sta _VDC_destl                      ; Store low byte destination address
    lda #$30                            ; Load $20 for high bye of $3000
    sta _VDC_desth                      ; Store low byte destination address
    jsr _VDC_RedefineCharset_core       ; Jump to redefine charset routine

; ------------------------------------------------------------------------------------------
_VDC_CopyMemToVDC_core:
; Function to copy memory from VDC memory to standard memory
; Input:	VDC_addrh = high byte of source address
;			VDC_addrl = low byte of source address
;			VDC_tmp1 = number of 256 byte pages to copy
;			VDC_tmp2 = length in last page to copy
; ------------------------------------------------------------------------------------------

    ; Set number of pages
	lda #$0F							; Set 16 pages for text plus attributes
	sta pages							; Store as pages
	
	; Set length of last page ($FF)
    lda #$FF                            ; Load 255 for 256 characters
    sta length                          ; Store as length

	; Set address pointer in zero-page
	lda #$CF							; Obtain low byte in A
	sta ZP1								; Store low byte in pointer
	lda #$1D							; Obtain high byte in A
	sta ZP2								; Store high byte in pointer

	; Hi-byte of the source VDC address to register 18
	ldx #VDC_UPDATEADRESSHIGH    		; Load $12 for register 18 (VDC RAM address high) in X	
	lda #$00        	        		; Load high byte of address in A
	jsr VDC_Write						; Write VDC

	; Low-byte of the source VDC address to register 19
	inx 								; Increase X for register 19 (VDC RAM address low)
	jsr VDC_Write						; Write VDC

	; Start of copy loop
	ldy #$00    						; Set Y as counter on 0
	
	; Read value and store at VDC address
copyloopm2v:							; Start of copy loop
	lda (ZP1),y							; Load source data
	ldx #VDC_DATA    					; Load $1f for register 31 (VDC data) in X
	jsr VDC_Write						; Write VDC

	; Increase source address (VDC auto increments)
	inc ZP1								; Increment low byte of source address
	bne nextm2v1						; If not yet zero, branch to next label
	inc ZP2								; Increment high byte of source address
nextm2v1:								; Next label
	dec length  						; Decrease low byte of length
	lda length  						; Load low byte of length to A
	cmp #$ff							; Check if below zero
	bne copyloopm2v						; Continue loop if not yet below zero
	dec pages				    		; Decrease high byte of length
	lda pages   						; Load high byte of length to A
	cmp #$ff							; Check if below zero
	bne copyloopm2v						; Continue loop if not yet below zero

    ; Wait for key
waitkey:
    jsr GETIN
    beq waitkey

	; Reset charsets
	jsr DLCHR							; Call kernal routine for restoring VDC charsets

	; Clear screens
	jsr CINT							; Call CINT kernal routine for clearing screens
	jsr SWAPPER							; Switch to 80 column again

    ; return to BASIC
	rts

; ------------------------------------------------------------------------------------------
_VDC_RedefineCharset_core:
; Function to copy charset definition from normal memory to VDC
; Input:	VDC_addrh = (source>>8) & $ff;			// Obtain high byte of destination address
;			VDC_addrl = source & $ff;				// Obtain low byte of destination address
;			VDC_tmp2 = sourcebank;					// Obtain bank number for source
;			VDC_desth = (dest>>8) & $ff;			// Obtain high byte of destination address
;			VDC_destl = dest & $ff;				// Obtain low byte of destination address
;			VDC_tmp1 = lengthinchars;				// Obtain number of characters to copy
; ------------------------------------------------------------------------------------------

	; Set address pointer in zero-page
	lda _VDC_addrl						; Obtain low byte in A
	sta ZP1								; Store low byte in pointer
	lda _VDC_addrh						; Obtain high byte in A
	sta ZP2								; Store high byte in pointer

	; Hi-byte of the destination VDC address to register 18
	ldx #VDC_UPDATEADRESSHIGH    		; Load $12 for register 18 (VDC RAM address high) in X	
	lda _VDC_desth		        		; Load high byte of address in A
	jsr VDC_Write						; Write VDC

	; Low-byte of the destination VDC address to register 19
	inx 								; Increase X for register 19 (VDC RAM address low)
	lda _VDC_destl      				; Load low byte of address in A
	jsr VDC_Write						; Write VDC

	; Start of copy loop
	ldy #$00    						; Set Y as counter on 0
looprc1:								; Start of outer loop
	
	; Read value from data register
looprc2:								; Start of 8 bytes character copy loop
	lda (ZP1),y							; Load from source address
	ldx #VDC_DATA    					; Load $1f for register 31 (VDC data) in X
	jsr VDC_Write						; Write VDC

	; Count 8 bytes per char
	iny 								; Increase Y counter
	cpy #$08    						; Is counter at 8?
	bcc looprc2				        	; If not yet 8, go to start of char copy loop

	; Add 8 bytes of zero padding per char
	lda #$00    						; Set 0 value to use as padding in A
looprc3:								; Start of padding loop
	jsr VDC_Write						; Write VDC
	dey 								; Decrease Y counter
	bne looprc3		        			; Continue padding looop if counter is not yet zero

	; Next character
	clc 								; Clear carry
	lda ZP1		       				 	; Load low byte of source address in A
	adc #$08    						; Add 8 to address with carry
	sta ZP1		       				 	; Store new address low byte
	lda ZP2     						; Load high byte of source address in A
	adc #$00    						; Add zero with carry to A
	sta ZP2        						; Store new address high byte
	dec length			        	    ; Decrease character length counter
	bne looprc1				        	; Branch for outer loop if not yet zero

	; Copy one final char
	ldy #$00       						; Set Y as counter on 0
looprc4:								; Start of 8 bytes character copy loop
	lda (ZP1),y							; Load from source address
	ldx #VDC_DATA    					; Load $1f for register 31 (VDC data) in X
	jsr VDC_Write						; Write VDC

	; Count 8 bytes per char
	iny 								; Increase Y counter
	cpy #$08    						; Is counter at 8?
	bcc looprc4       					; If not yet 8, go to start of char copy loop

; Add 8 bytes of zero padding per char
	lda #$00    						; Set 0 value to use as padding in A
looprc5:								; Start of padding loop
	jsr VDC_Write						; Write VDC
	dey 								; Decrease Y counter
	bne looprc5		        			; Continue padding looop if counter is not yet zero
	rts

; Generic helper routines

; ------------------------------------------------------------------------------------------
VDC_Write:
; Function to do a VDC read and wait for ready status
; Input:	X = register number
; 			A = value to write
; ------------------------------------------------------------------------------------------

	stx VDC_ADDRESS_REGISTER            ; Store X in VDC address register
notyetreadywrite:						; Start of wait loop to wait for VDC status ready
	bit VDC_ADDRESS_REGISTER            ; Check status bit 7 of VDC address register
	bpl notyetreadywrite                ; Continue loop if status is not ready
	sta VDC_DATA_REGISTER               ; Store A to VDC data
	rts

; ------------------------------------------------------------------------------------------
textout:
; Function to print a text to screen
; Input:	ZP1 = low byte of text address
; 			ZP2 = high byte of text address
; ------------------------------------------------------------------------------------------

	ldy #$00							; Set index to zero
textout_loop:
	lda (ZP1),y							; Get character
	beq textout_end						; Text end?
	jsr BSOUT							; Print char
	iny									; Next char
	jmp textout_loop					; Loop
textout_end:
	rts									; Return

switchvdcmessage:
.byte "switch to 80 column mode to view.",0